Armand opens the meeting at 15:00 BST

### Summary meeting notes

The meeting centred on integrating Eclipse Symphony into Margo, highlighting Symphony's role as an open-source workload fleet manager. Its microservices-based architecture, protocol agnosticism, and specific system interaction providers were detailed. Key features include state seeking, an information graph, and workflow management. Symphony emphasises minimal opinionated systems and platform agnosticism. The discussion also addressed integrating Margo's management API as a microservice, employing providers for state management, and the potential for multi-version management of solutions. The goal is to leverage Symphony to orchestrate Margo's desired states and workloads.

### Action Items
- [ ] Follow up on any questions in the Discord channel.
- [ ] Armand to send an email to summarise the discussion and next steps.

### Meeting Minutes

**Overview of Eclipse Symphony and Interoperability**
Hashi introduces Eclipse Symphony, a project launched a few years ago and donated to the Eclipse Foundation last year. He discusses the concept of interoperability, highlighting that interpretations vary among device vendors, application developers, and end users. Symphony's approach focuses on delivering a consistent management experience rather than guaranteeing seamless integration across different vendors.

**Symphony's Architecture and High-Level Abstractions**
Hashi introduces Eclipse Symphony, a project launched a few years ago and donated to the Eclipse Foundation last year. He discusses the concept of interoperability, highlighting that interpretations vary among device vendors, application developers, and end users. Symphony's approach focuses on delivering a consistent management experience rather than guaranteeing seamless integration across different vendors.

**Information Graph and Workflow in Symphony**
Hashi discusses the information graph, which effectively organises data and supports various reporting structures. They highlight the workflow aspect, setting clear goals and pathways to achieve desired outcomes. Emphasising end-to-end observability, Hashi covers consistent monitoring, reporting, and auditing, while introducing the "Ultra" concept to differentiate Symphony from other orchestration layers.

**Symphony's Principles and API Design**
Hashi outlines the principles of Symphony, emphasising the importance of providing value in opinions and avoiding unnecessary duplication. The design of the low-level Symphony API offers primitives for constructing more opinionated systems, such as Margo. Furthermore, Hashi describes Symphony's architecture, which incorporates microservices, middleware, and protocol bindings, while highlighting the need for providers to encapsulate knowledge about specific systems to maintain platform agnosticism.

**Symphony's Middleware and Protocol Bindings**
Hashi explains the middleware layer, which addresses cross-cutting concerns such as observability, authentication, and billing. It also describes protocol bindings that enable Symphony to be protocol-agnostic, supporting various communication methods. Additionally, Hashi highlights the use of OpenTelemetry for system metrics and events, with options to add more bindings as needed. The use of providers encapsulates knowledge about specific systems, keeping Symphony isolated from platform-specific capabilities.

**Symphony's Object Model and Workflow Management**
Hashi introduces the Symphony object model, which encompasses solutions, targets, instances, campaigns, and information graphs. Solutions represent software components, while targets denote deployable endpoints. Instances are deployments mapping software to one or multiple targets, and campaigns define workflows with distinct stages and activations.

**Symphony's Information Graph and Additional Objects**
Hashi describes the information graph, consisting of nodes and edges linked to various graph structures. It introduces additional objects like AI models and devices, which influence state-seeking decisions. Furthermore, Hashi presents solution containers for multi-version management and historical deployment tracking, emphasising a least opinionated object model that allows for customisation.

**Symphony's Integration with Margo**
Armand inquires about the integration of Margo's management interface with Symphony. Hashi responds, explaining that Margo's API will function as a microservice within the manager layer, facilitating a unified Margo API. Armand clarifies that Margo will utilise Symphony as a fleet manager to orchestrate objects and workloads, with the desired state API managed by a different group. Hashi highlights Symphony's flexible architecture, allowing for deep implementation as necessary.

**Conclusion and Next Steps**
Armand thanked Hashi for the detailed explanation, emphasising the goal of adopting Symphony as the official open-source workload fleet manager. He encouraged participants to address any follow-up questions on Discord and mentioned that an email would be sent to summarise the discussion and highlight key concerns. Hashi expressed appreciation for everyone's participation, and the meeting concluded with Armand's gratitude.
